# Full Page Cache

- uses redis as a backend but other backends could be implemented
- application decides what gets cached and for how long
- supports tags and post-processing

## Requirements

- composer
- redis-server

## Configuration

- put directory lg-fpc-config in application root
- copy sample cfg-files and edit as necessary

## Behaviour

1. on a cache miss the application decides whether or not page should be cached and which parameters are relevant
2. cache registers page with meta data of page
3. background worker fetches and stores page in cache
4. worker checks for old pages i.e. the refresh interval has been reached and fetches and stores them once again

## Advantages

- it is fast, time to deliver a page is only around 10-15ms
- once something is cached, it is refreshed at a given interval by a worker, so even pages that are rarely visited are fast
- application decides what to cache (no cache pollution)
- cache understands state and caches a version which contains all versions in a single file, 
  when a page is delivered the cache quickly renders the page for the correct state
- transparent integration of different versions of content
- data in cache is being compressed to save memory
- robust: can handle missing data and a comlete lack of the backend (added overhead depends on defined timeouts, for redis it can be as little as 100ms)
- the load generated by rendering wordpress pages will become constant because the cache is refreshing them regularly, everything else is delivered by the cache with minimum resource consumption
- easily integrates with interactions like forms, i.e. a POST request is never cached or served by the cache
- dynamic content beyond simple state can be handled by a post-processing callback (like XSRF-Tokens, Name of logged in Customer, etc.pp.)

## Usage / Integration Code
 
### option index.php

When you update wordpress, you have to make sure the index.php remains unchanged.

```
<?php
/**
 * Front to the WordPress application. This file doesn't do anything, but loads
 * wp-blog-header.php which does and tells WordPress to load the theme.
 *
 * @package WordPress
 */

/* begin fullpage cache */
require_once 'wp-content/plugins/lg-fpc/bootstrap.php';
require_once 'wp-content/plugins/lg-fpc/startup.php';
/* end fullpage cache */

/**
 * Tells WordPress to load the WordPress theme and output it.
 *
 * @var bool
 */
define('WP_USE_THEMES', true);

/** Loads the WordPress Environment and Template */
require( dirname( __FILE__ ) . '/wp-blog-header.php' );
```

### option fpc.php

This way the index.php could change without a problem but you have to make sure that the fpc.php is being used to route all requests.
So you have to make the necessary adjustments to your vhost/.htaccess (or other config depending on your webserver).

```
<?php
require_once 'wp-content/plugins/lg-fpc/bootstrap.php';
require_once 'wp-content/plugins/lg-fpc/startup.php';
require_once 'index.php';
```

### handling state (templates)

A callback which you define (config/profile.php) controls the state.

```
$config->setProcessTagsCallback(function() {
	$tags = array();
	if(array_key_exists('is_logged_in', $_SESSION)) {
		$tags[] = CACHE_TAG_ACCOUNT_SESSION_ACTIVE;
	} else {
		$tags[] = CACHE_TAG_ACCOUNT_SESSION_INACTIVE;
	}
	return $tags;
});
```

In the template you define versions in place.

```
$cache = \Lg\FullPageCache::getInstance();

<ul>
   <li>
      <a class="link_action" href="/home">Home</a>
   </li>
   
   <?php $cache->renderTag(CACHE_TAG_ACCOUNT_SESSION_ACTIVE, function() { ?>
      <li>
         <a class="link_action" href="/account/dashboard">My Account</a>
      </li>
      <li>
         <a class="link_action" href="/account/logout">Logout</a>
      </li>
   <?php }) ?>
   
   <?php $cache->renderTag(CACHE_TAG_ACCOUNT_SESSION_INACTIVE, function() { ?>
      <li>
         <a class="link_action" href="/account/login">Login</a>
      </li>
   <?php }) ?>
</ul>
```

### deciding what to cache

The application has to register a page to the cache like so.

```
$cache = \Lg\FullPageCache::getInstance();
$cache->registerPage(PAGE_KEY_HOME, 600); // refresh every 5 minutes
```

A good place for this is at the end of a page template but it can happen anywhere in your code.